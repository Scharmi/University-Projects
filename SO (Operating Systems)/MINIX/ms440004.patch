diff -rupNEZbB origin/usr/include/minix/callnr.h new/usr/include/minix/callnr.h
--- origin/usr/include/minix/callnr.h	2023-06-18 18:51:44.822327000 +0200
+++ new/usr/include/minix/callnr.h	2023-08-25 14:30:59.758798419 +0200
@@ -58,8 +58,11 @@
 #define PM_GETEPINFO		(PM_BASE + 45)
 #define PM_GETPROCNR		(PM_BASE + 46)
 #define PM_GETSYSINFO		(PM_BASE + 47)
+#define PM_WAIT_FOR_PARENT     (PM_BASE + 48)
+#define PM_WAIT_FOR_CHILD     (PM_BASE + 49)
+#define PM_WAIT_FOR_SIBLING   (PM_BASE + 50)
 
-#define NR_PM_CALLS		48	/* highest number from base plus one */
+#define NR_PM_CALLS		51	/* highest number from base plus one */
 
 /*===========================================================================*
  *				Calls to VFS				     *
diff -rupNEZbB origin/usr/include/unistd.h new/usr/include/unistd.h
--- origin/usr/include/unistd.h	2023-06-18 18:51:45.290326000 +0200
+++ new/usr/include/unistd.h	2023-08-25 17:32:05.781047768 +0200
@@ -143,7 +143,9 @@ int	 tcsetpgrp(int, pid_t);
 __aconst char *ttyname(int);
 int	 unlink(const char *);
 ssize_t	 write(int, const void *, size_t);
-
+void wait_for_parent(void);
+void wait_for_child(void);
+void wait_for_sibling(void);
 
 /*
  * IEEE Std 1003.2-92, adopted in X/Open Portability Guide Issue 4 and later
diff -rupNEZbB origin/usr/src/include/unistd.h new/usr/src/include/unistd.h
--- origin/usr/src/include/unistd.h	2023-06-18 18:54:37.270414000 +0200
+++ new/usr/src/include/unistd.h	2023-08-25 17:32:03.765054278 +0200
@@ -143,6 +143,9 @@ int	 tcsetpgrp(int, pid_t);
 __aconst char *ttyname(int);
 int	 unlink(const char *);
 ssize_t	 write(int, const void *, size_t);
+void wait_for_parent(void);
+void wait_for_child(void);
+void wait_for_sibling(void);
 
 
 /*
diff -rupNEZbB origin/usr/src/lib/libc/misc/Makefile.inc new/usr/src/lib/libc/misc/Makefile.inc
--- origin/usr/src/lib/libc/misc/Makefile.inc	2023-06-18 18:54:39.310417000 +0200
+++ new/usr/src/lib/libc/misc/Makefile.inc	2023-08-25 17:59:21.548513025 +0200
@@ -8,3 +8,4 @@ SRCS+=	initfini.c
 
 # for -fstack-protector
 SRCS+=	stack_protector.c
+SRCS+= wait_for_relative.c
diff -rupNEZbB origin/usr/src/lib/libc/misc/wait_for_relative.c new/usr/src/lib/libc/misc/wait_for_relative.c
--- origin/usr/src/lib/libc/misc/wait_for_relative.c	1970-01-01 01:00:00.000000000 +0100
+++ new/usr/src/lib/libc/misc/wait_for_relative.c	2023-08-26 19:33:49.415117604 +0200
@@ -0,0 +1,19 @@
+#include <unistd.h>
+#include <lib.h>
+#include <stdio.h>
+#include "namespace.h"
+
+void wait_for_sibling(void) {
+    message m;
+    _syscall(PM_PROC_NR, PM_WAIT_FOR_SIBLING, &m);
+}
+
+void wait_for_child(void) {
+    message m;
+    _syscall(PM_PROC_NR, PM_WAIT_FOR_CHILD, &m);
+}
+
+void wait_for_parent(void) {
+    message m;
+    _syscall(PM_PROC_NR, PM_WAIT_FOR_PARENT, &m);
+}
\ No newline at end of file
diff -rupNEZbB origin/usr/src/minix/include/minix/callnr.h new/usr/src/minix/include/minix/callnr.h
--- origin/usr/src/minix/include/minix/callnr.h	2023-06-18 18:54:56.874448000 +0200
+++ new/usr/src/minix/include/minix/callnr.h	2023-08-25 18:27:14.682251516 +0200
@@ -58,8 +58,11 @@
 #define PM_GETEPINFO		(PM_BASE + 45)
 #define PM_GETPROCNR		(PM_BASE + 46)
 #define PM_GETSYSINFO		(PM_BASE + 47)
+#define PM_WAIT_FOR_PARENT     (PM_BASE + 48)
+#define PM_WAIT_FOR_CHILD     (PM_BASE + 49)
+#define PM_WAIT_FOR_SIBLING   (PM_BASE + 50)
 
-#define NR_PM_CALLS		48	/* highest number from base plus one */
+#define NR_PM_CALLS		51	/* highest number from base plus one */
 
 /*===========================================================================*
  *				Calls to VFS				     *
diff -rupNEZbB origin/usr/src/minix/servers/pm/forkexit.c new/usr/src/minix/servers/pm/forkexit.c
--- origin/usr/src/minix/servers/pm/forkexit.c	2023-06-18 18:54:59.686453000 +0200
+++ new/usr/src/minix/servers/pm/forkexit.c	2023-08-26 19:12:40.008231829 +0200
@@ -27,6 +27,7 @@
 #include <sys/ptrace.h>
 #include <sys/resource.h>
 #include <signal.h>
+#include <minix/config.h>
 #include "mproc.h"
 
 #define LAST_FEW            2	/* last few slots reserved for superuser */
@@ -112,7 +113,9 @@ int do_fork()
   /* Find a free pid for the child and put it in the table. */
   new_pid = get_free_pid();
   rmc->mp_pid = new_pid;	/* assign pid to child */
-
+  rmc->waiting_for_child = 0;
+  rmc->waiting_for_parent = 0;
+  rmc->waiting_for_sibling = 0;
   memset(&m, 0, sizeof(m));
   m.m_type = VFS_PM_FORK;
   m.VFS_PM_ENDPT = rmc->mp_endpoint;
diff -rupNEZbB origin/usr/src/minix/servers/pm/main.c new/usr/src/minix/servers/pm/main.c
--- origin/usr/src/minix/servers/pm/main.c	2023-06-18 18:54:59.690453000 +0200
+++ new/usr/src/minix/servers/pm/main.c	2023-08-26 19:43:57.576641071 +0200
@@ -15,6 +15,7 @@
 #include <minix/ds.h>
 #include <minix/type.h>
 #include <minix/endpoint.h>
+#include <minix/config.h>
 #include <minix/minlib.h>
 #include <minix/type.h>
 #include <minix/vm.h>
@@ -211,7 +212,9 @@ static int sef_cb_init_fresh(int UNUSED(
 			rmp->mp_scheduler = NONE;
 			rmp->mp_nice = get_nice_value(SRV_Q);
 		}
-
+		rmp->waiting_for_child = 0;
+		rmp->waiting_for_parent = 0;
+		rmp->waiting_for_sibling = 0;
 		/* Get kernel endpoint identifier. */
 		rmp->mp_endpoint = ip->endpoint;
 
diff -rupNEZbB origin/usr/src/minix/servers/pm/mproc.h new/usr/src/minix/servers/pm/mproc.h
--- origin/usr/src/minix/servers/pm/mproc.h	2023-06-18 18:54:59.690453000 +0200
+++ new/usr/src/minix/servers/pm/mproc.h	2023-08-25 21:37:54.774333918 +0200
@@ -22,6 +22,9 @@ EXTERN struct mproc {
   pid_t mp_wpid;		/* pid this process is waiting for */
   int mp_parent;		/* index of parent process */
   int mp_tracer;		/* index of tracer process, or NO_TRACER */
+  int waiting_for_child;
+  int waiting_for_parent;
+  int waiting_for_sibling;
 
   /* Child user and system times. Accounting done on child exit. */
   clock_t mp_child_utime;	/* cumulative user time of children */
diff -rupNEZbB origin/usr/src/minix/servers/pm/proto.h new/usr/src/minix/servers/pm/proto.h
--- origin/usr/src/minix/servers/pm/proto.h	2023-06-18 18:54:59.694453000 +0200
+++ new/usr/src/minix/servers/pm/proto.h	2023-08-25 14:11:09.721816029 +0200
@@ -89,3 +89,7 @@ struct mproc *find_proc(pid_t lpid);
 int nice_to_priority(int nice, unsigned *new_q);
 int pm_isokendpt(int ep, int *proc);
 void tell_vfs(struct mproc *rmp, message *m_ptr);
+
+int do_wait_for_child(void);
+int do_wait_for_parent(void);
+int do_wait_for_sibling(void);
\ No newline at end of file
diff -rupNEZbB origin/usr/src/minix/servers/pm/signal.c new/usr/src/minix/servers/pm/signal.c
--- origin/usr/src/minix/servers/pm/signal.c	2023-06-18 18:54:59.698453000 +0200
+++ new/usr/src/minix/servers/pm/signal.c	2023-08-27 16:44:13.946047375 +0200
@@ -869,3 +869,74 @@ void vm_notify_sig_wrapper(endpoint_t ep
 	}
   }
 }
+int do_wait_for_child() {
+    mproc[who_p].waiting_for_child = 1;
+    int child_pid = -1;
+    int child_id;
+    for (int i = 0; i < NR_PROCS; i++) {
+        if (mproc[mproc[i].mp_parent].mp_pid == mproc[who_p].mp_pid) {
+            if(mproc[i].waiting_for_parent == 1) {
+                child_pid = mproc[i].mp_pid;
+                child_id = i;
+                break;
+            }
+        }
+    }
+    if(child_pid == -1) {
+        stop_proc(&mproc[who_p], 1);
+        return 0;
+    } else {
+        mproc[child_id].waiting_for_parent = 0;
+        mproc[who_p].waiting_for_child = 0;
+        try_resume_proc(&mproc[child_id]);
+    }
+    return 0;
+}
+int do_wait_for_parent() {
+    mproc[who_p].waiting_for_parent = 1;
+    int parent_pid = -1;
+    int parent_id;
+    for (int i = 0; i < NR_PROCS; i++) {
+        if (mproc[i].mp_pid == mproc[mproc[who_p].mp_parent].mp_pid) {
+            if(mproc[i].waiting_for_child == 1) {
+                parent_pid = mproc[i].mp_pid;
+                parent_id = i;
+                break;
+            }
+        }
+    }
+    if(parent_pid == -1) {
+        stop_proc(&mproc[who_p], TRUE);
+        return 0;
+    } else {
+        //wake up parent
+        mproc[parent_id].waiting_for_child = 0;
+        mproc[who_p].waiting_for_parent = 0;
+        try_resume_proc(&mproc[parent_id]);
+    }
+    return 0;
+}
+
+int do_wait_for_sibling() {
+    mproc[who_p].waiting_for_sibling = 1;
+    int sibling_pid = -1;
+    int sibling_id;
+    for (int i = 0; i < NR_PROCS; i++) {
+        if (mproc[i].mp_parent == mproc[who_p].mp_parent && mproc[i].mp_pid != mproc[who_p].mp_pid) {
+            if(mproc[i].waiting_for_sibling == 1) {
+                sibling_pid = mproc[i].mp_pid;
+                sibling_id = i;
+                break;
+            }
+        }
+    }
+    if(sibling_pid == -1) {
+		stop_proc(&mproc[who_p], TRUE);
+        return 0;
+    } else {
+        mproc[sibling_id].waiting_for_sibling = 0;
+        mproc[who_p].waiting_for_sibling = 0;
+		try_resume_proc(&mproc[sibling_id]);
+    }
+    return 0;
+}
\ No newline at end of file
diff -rupNEZbB origin/usr/src/minix/servers/pm/table.c new/usr/src/minix/servers/pm/table.c
--- origin/usr/src/minix/servers/pm/table.c	2023-06-18 18:54:59.698453000 +0200
+++ new/usr/src/minix/servers/pm/table.c	2023-08-27 17:24:49.485469070 +0200
@@ -58,5 +58,9 @@ int (* const call_vec[NR_PM_CALLS])(void
 	CALL(PM_EXEC_RESTART)	= do_execrestart,
 	CALL(PM_GETEPINFO)	= do_getepinfo,		/* getepinfo(2) */
 	CALL(PM_GETPROCNR)	= do_getprocnr,		/* getprocnr(2) */
-	CALL(PM_GETSYSINFO)	= do_getsysinfo		/* getsysinfo(2) */
+	CALL(PM_GETSYSINFO)	= do_getsysinfo,		/* getsysinfo(2) */
+	CALL(PM_WAIT_FOR_CHILD) = do_wait_for_child,	/* wait_for_child(2) */
+	CALL(PM_WAIT_FOR_PARENT) = do_wait_for_parent,	/* wait_for_parent(2) */
+	CALL(PM_WAIT_FOR_SIBLING) = do_wait_for_sibling	/* wait_for_sibling(2) */
+
 };
diff -rupNEZbB origin/usr/.vscode/settings.json new/usr/.vscode/settings.json
--- origin/usr/.vscode/settings.json	1970-01-01 01:00:00.000000000 +0100
+++ new/usr/.vscode/settings.json	2023-08-26 18:10:54.771621987 +0200
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "wait.h": "c"
+    }
+}
\ No newline at end of file
